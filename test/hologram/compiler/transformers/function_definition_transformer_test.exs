defmodule Hologram.Compiler.FunctionDefinitionTransformerTest do
  use Hologram.TestCase, async: true

  alias Hologram.Compiler.{Context, FunctionDefinitionTransformer}
  alias Hologram.Compiler.IR.{AccessOperator, AtomType, FunctionDefinition, IntegerType, Variable}

  @context %Context{module: Abc}

  describe "transform/4" do
    test "name" do
      code = """
      def test(1, 2) do
      end
      """

      ast = ast(code)

      assert %FunctionDefinition{name: :test} =
              FunctionDefinitionTransformer.transform(ast, @context)
    end

    test "arity" do
      code = """
      def test(1, 2) do
      end
      """

      ast = ast(code)

      assert %FunctionDefinition{arity: 2} =
              FunctionDefinitionTransformer.transform(ast, @context)
    end

    test "params" do
      code = """
      def test(a, b) do
      end
      """

      ast = ast(code)

      assert %FunctionDefinition{} =
               result = FunctionDefinitionTransformer.transform(ast, @context)

      expected = [
        %Variable{name: :a},
        %Variable{name: :b}
      ]

      assert result.params == expected
    end

    test "bindings" do
      code = """
      def test(1, %{a: x, b: y}) do
      end
      """

      ast = ast(code)

      assert %FunctionDefinition{} =
               result = FunctionDefinitionTransformer.transform(ast, @context)

      expected = [
        x:
          {1,
           [
             %AccessOperator{
               key: %AtomType{value: :a}
             },
             %Variable{name: :x}
           ]},
        y:
          {1,
           [
             %AccessOperator{
               key: %AtomType{value: :b}
             },
             %Variable{name: :y}
           ]}
      ]

      assert result.bindings == expected
    end

    test "body, single expression" do
      code = """
      def test do
        1
      end
      """

      ast = ast(code)

      assert %FunctionDefinition{} =
               result = FunctionDefinitionTransformer.transform(ast, @context)

      assert result.body == [%IntegerType{value: 1}]
    end

    test "body, multiple expressions" do
      code = """
      def test do
        1
        2
      end
      """

      ast = ast(code)

      assert %FunctionDefinition{} =
               result = FunctionDefinitionTransformer.transform(ast, @context)

      expected = [
        %IntegerType{value: 1},
        %IntegerType{value: 2}
      ]

      assert result.body == expected
    end

    test "handles function definitions generated by macros" do
      ast =
        {:def, [context: Abc.Bcd, import: Kernel],
         [
           {:route, [context: Abc.Bcd], Abc.Bcd},
           [do: {:__block__, [], ["test"]}]
         ]}

      assert %FunctionDefinition{} = FunctionDefinitionTransformer.transform(ast, @context)
    end
  end

  describe "transform_params/2" do
    test "no params" do
      # def test do
      # end

      params = nil
      result = FunctionDefinitionTransformer.transform_params(params, @context)

      assert result == []
    end

    test "vars" do
      # def test(a, b) do
      # end

      params = [{:a, [line: 1], nil}, {:b, [line: 1], nil}]
      result = FunctionDefinitionTransformer.transform_params(params, @context)

      expected = [
        %Variable{name: :a},
        %Variable{name: :b}
      ]

      assert result == expected
    end

    test "primitive types" do
      # def test(:a, 2) do
      # end

      params = [:a, 2]
      result = FunctionDefinitionTransformer.transform_params(params, @context)

      expected = [
        %AtomType{value: :a},
        %IntegerType{value: 2}
      ]

      assert result == expected
    end
  end
end
